# ********************************************************************
#
# Makefile used for building YAMON.
# 
# After adapting the "Environment specifics" section of this makefile
# (see below), the makefile may be used in the specific build 
# environment.
#
# Note, that this makefile uses forward slashes '/' for directory
# references.
#
# The default target (all) builds YAMON in two formats :
#
# yamon-<rev>.fl :  The YAMON image used for loading YAMON to a
#		    target board using the parallel port.
#
# yamon-<rev>.bin : The YAMON image (binary) used for programming
#		    an (E)PROM.
#
# Other targets are : 
#
# install :	    Creates the necessary directories and
#		    builds the tools needed for the main build.
# clean :   	    Deletes all files generated by makefile.
# depend :  	    Builds dependency files.
# dis :		    Generates disassembly files :
#			reset-<rev>.dis
#			EL/yamon-<rev>_el.dis
#			EB/yamon-<rev>_eb.dis
# release : 	    First deletes all files generated by makefile (make clean).
#  		    Then builds YAMON images (make all).
#		    Then generates disassembly files (make dis).
#
# ********************************************************************
#
# mips_start_of_legal_notice
# 
# Copyright (c) 2008 MIPS Technologies, Inc. All rights reserved.
#
#
# Unpublished rights (if any) reserved under the copyright laws of the
# United States of America and other countries.
#
# This code is proprietary to MIPS Technologies, Inc. ("MIPS Technologies").
# Any copying, reproducing, modifying or use of this code (in whole or in
# part) that is not expressly permitted in writing by MIPS Technologies or
# an authorized third party is strictly prohibited. At a minimum, this code
# is protected under unfair competition and copyright laws. Violations
# thereof may result in criminal penalties and fines.
#
# MIPS Technologies reserves the right to change this code to improve
# function, design or otherwise. MIPS Technologies does not assume any
# liability arising out of the application or use of this code, or of any
# error or omission in such code. Any warranties, whether express,
# statutory, implied or otherwise, including but not limited to the implied
# warranties of merchantability or fitness for a particular purpose, are
# excluded. Except as expressly provided in any written license agreement
# from MIPS Technologies or an authorized third party, the furnishing of
# this code does not give recipient any license to any intellectual property
# rights, including any patent rights, that cover this code.
#
# This code shall not be exported or transferred for the purpose of
# reexporting in violation of any U.S. or non-U.S. regulation, treaty,
# Executive Order, law, statute, amendment or supplement thereto.
#
# This code constitutes one or more of the following: commercial computer
# software, commercial computer software documentation or other commercial
# items. If the user of this code, or any related documentation of any kind,
# including related technical data or manuals, is an agency, department, or
# other entity of the United States government ("Government"), the use,
# duplication, reproduction, release, modification, disclosure, or transfer
# of this code, or any related documentation of any kind, is restricted in
# accordance with Federal Acquisition Regulation 12.212 for civilian
# agencies and Defense Federal Acquisition Regulation Supplement 227.7202
# for military agencies. The use of this code by the Government is further
# restricted in accordance with the terms of the license agreement(s) and/or
# applicable contract terms and conditions covering this code from MIPS
# Technologies or an authorized third party.
#
# 
# mips_end_of_legal_notice
# 
#
# ********************************************************************


# ********************************************************************
# Environment specifics.
#
# These (down to and including BSS_OLD, see below) are the only 
# things, you have to adapt to your specific environment.
# ********************************************************************

# Tool-chain used for compilation of target code (cygnus, sde or linux).
#TOOLCHAIN = cygnus
#TOOLCHAIN = sde
TOOLCHAIN = linux

# Gcc major version number affects gcc options
# If it is not set the Makefile will attempt to determine the version
# in use automatically
#GCC_VERSION=2
#GCC_VERSION=3
#GCC_VERSION=4

ifeq ($(TOOLCHAIN),cygnus)
# version 2.96
CC        = mipsisa32-elf-gcc
LD        = mipsisa32-elf-ld
OBJCOPY   = mipsisa32-elf-objcopy
OBJDUMP   = mipsisa32-elf-objdump
endif

ifeq ($(TOOLCHAIN),sde)
# sde version 4.1sb (gcc version 2.96)
# sde version 5.03.06 (gcc version 2.96)
# sde version 6.01 (gcc version 3.4)
# sde version 7.01.00-exp (gcc version 4.2.3)
CC        = sde-gcc
LD        = sde-ld
OBJCOPY   = sde-objcopy
OBJDUMP   = sde-objdump
endif

ifeq ($(TOOLCHAIN),linux)
CC        = mips64-linux-gnu-gcc
LD        = mips64-linux-gnu-ld
OBJCOPY   = mips64-linux-gnu-objcopy
OBJDUMP   = mips64-linux-gnu-objdump
endif

ifndef GCC_VERSION
GCC_VERSION = $(shell $(CC) -v 2>&1 | sed -n -e 's/^gcc version \([0-9]\).*/\1/p')
endif

# Perl interpreter
PERL      = perl

# Shell commands
RM        = rm
CD	  = cd
MKDIR     = mkdir
ECHO	  = echo
CAT       = cat

# tags command
TAGS      = etags
ETAGS	  = --regex='{asm}/[ \t]*\(NESTED\|LEAF\|SLEAF\)([ \t]*\([^) \t]+\)[ \t]*)/\2/'

# ********************************************************************
# Different assemblers have different requirements for how to
# indicate that the next section is bss :
#
# Some use :   .bss
# Others use : .section bss
#
# We select which to use based on whether symbol BSS_OLD is 0 or not.
#  
# BSS_OLD = 0  : .bss 
# BSS_OLD != 0 : .section bss
# ********************************************************************
BSS_OLD = 0

# ********************************************************************
# Revision
# ********************************************************************
REVMAJ = 02
REVMIN = 16

# ********************************************************************
# Target prefix.
# ********************************************************************
IMAGE_BASENAME = yamon
IMAGENAME      = $(IMAGE_BASENAME)-$(REVMAJ).$(REVMIN)
RESET	       = reset-$(REVMAJ).$(REVMIN)

# ********************************************************************
# Target filenames for little and big endian code.
# ********************************************************************
SREC_EL = $(IMAGENAME)_el.rec
ELF_EL  = $(IMAGENAME)_el.elf
MAP_EL  = $(IMAGENAME)_el.map
DIS_EL	= $(IMAGENAME)_el.dis

SREC_EB = $(IMAGENAME)_eb.rec
ELF_EB  = $(IMAGENAME)_eb.elf
MAP_EB  = $(IMAGENAME)_eb.map
DIS_EB	= $(IMAGENAME)_eb.dis

# ********************************************************************
# Make calls itself recursively in order to build the little- and 
# big-endian images.
# If ENDIAN is defined, this is such a recursive call.
# ********************************************************************

ifdef ENDIAN

# Setup the definitions required to build the little- or
# big-endian image (from directory bin/EL or bin/EB).

# Root directory of YAMON source code.
ROOT      = ./../..

# Directory where make is supposed to be invoked.
MAKEDIR   = ./..

# Directory where linker scripts reside.
LINKDIR   = $(MAKEDIR)/link

# Directories holding the source files.
SRCDIR    = \
	    $(ROOT)/arch/reset \
	    $(ROOT)/init \
	    $(ROOT)/pci \
	    $(ROOT)/exception \
            $(ROOT)/io \
            $(ROOT)/load \
            $(ROOT)/net \
            $(ROOT)/shell \
            $(ROOT)/sysenv \
            $(ROOT)/env \
            $(ROOT)/lib \
            $(ROOT)/sys \
	    $(ROOT)/sys/cpu \
            $(ROOT)/syscon \
\
            $(ROOT)/drivers/eeprom \
            $(ROOT)/drivers/flash \
            $(ROOT)/drivers/iic \
            $(ROOT)/drivers/rtc \
            $(ROOT)/drivers/serial \
            $(ROOT)/drivers/lan \
            $(ROOT)/drivers/ide \
\
	    $(ROOT)/arch/env/platform \
	    $(ROOT)/arch/exception/platform \
	    $(ROOT)/arch/isa/platform \
	    $(ROOT)/arch/shell/platform \
	    $(ROOT)/arch/shell/cpu \
	    $(ROOT)/arch/sys/platform \
\
	    $(ROOT)/arch/syscon/platform \
	    $(ROOT)/arch/syscon/platform/core \
	    $(ROOT)/arch/freq/platform \
	    $(ROOT)/arch/freq/platform/core \
	    $(ROOT)/arch/init/platform \
	    $(ROOT)/arch/init/platform/core \
	    $(ROOT)/arch/pci/platform \
	    $(ROOT)/arch/pci/platform/core \
\
	    $(ROOT)/arch/sys/cpu \
	    $(ROOT)/arch/syscon/cpu


ifeq ($(ENDIAN),EB)

# Linker script.
ifdef SIMULATE
LD_SCRIPT    = $(LINKDIR)/link_eb_sim.xn
else
LD_SCRIPT    = $(LINKDIR)/link_eb.xn
endif

# Various filenames.
IMAGE_SREC   = ./$(SREC_EB)
IMAGE_DIS    = ./$(DIS_EB)
IMAGE_ELF    = ./$(ELF_EB)
IMAGE_MAP    = ./$(MAP_EB)
FPUEMUL      = $(ROOT)/fpuemul/EB/fpuemul_eb.elf

# Limit for image (look in deleteall.fl for current value)
MAX_ADDRESS  = 9fce0000

else # EL

# Linker script.
ifdef SIMULATE
LD_SCRIPT    = $(LINKDIR)/link_el_sim.xn
else
LD_SCRIPT    = $(LINKDIR)/link_el.xn
endif

# Various filenames.
IMAGE_SREC   = ./$(SREC_EL)
IMAGE_DIS    = ./$(DIS_EL)
IMAGE_ELF    = ./$(ELF_EL)
IMAGE_MAP    = ./$(MAP_EL)
FPUEMUL      = $(ROOT)/fpuemul/EL/fpuemul_el.elf

# Limit for image (look in link/link.xn for current value)
MAX_ADDRESS  = 9fc78000

endif # ifeq ($(ENDIAN,EB))


else  # ifdef ENDIAN

# If ENDIAN is not defined, this makefile was called from the command prompt
# (i.e. "make"). 
# We will first make the boot vector code that determines endianness, then
# make the little- and big-endian images, then concatenate them.

# Setup the definitions required to make the boot vector code that 
# determines endianness (from bin directory).

# Root directory of YAMON source code.
ROOT      = ./..

# Directory where make is supposed to be invoked.
MAKEDIR   = .

# Directory where linker scripts reside.
LINKDIR   = $(MAKEDIR)/link

# The boot vector code is arbitrarily compiled for big endian.
ENDIAN       = EB

# Only one directory holds the source files for the boot vector code.
SRCDIR       = $(ROOT)/arch/reset/bootvector

# Linker script.
ifdef SIMULATE
LD_SCRIPT    = $(LINKDIR)/link_sim.xn
else
LD_SCRIPT    = $(LINKDIR)/link.xn
endif

# The reset code.
IMAGE_ELF         = ./$(RESET).elf
IMAGE_SREC        = ./$(RESET).rec
IMAGE_MAP         = ./$(RESET).map
IMAGE_DIS         = ./$(RESET).dis

# The concatenated srecord file
IMAGE_SREC_CONCAT = ./$(IMAGENAME).rec

# The final flash image.
IMAGE_FLASH  = ./$(IMAGENAME).fl

# Paths for making the little- and big-endian images.
EL_PATH      = ./EL
EB_PATH      = ./EB

endif # ifdef ENDIAN

# Workaround for 25Kf with Bonito - arch/pci/platform/core/pci_core.c
# WORKAROUND_BONITO   = -DBONITO_DEVID_HACK

# Workaround in case caches don't work
# WORKAROUND_NO_CACHE = -DNO_CACHE

# Option in case we want KSEG0 to be uncached
# KSEG0_UNCACHED = -DKSEG0_UNCACHED

# Difference between WORKAROUND_NO_CACHE and KSEG0_UNCACHED is :
# 
# * If WORKAROUND_NO_CACHE is defined, NO cacheops are used, and KSEG0 is 
#   configured as uncached.
# * If KSEG0_UNCACHED is defined (and WORKAROUND_NO_CACHE is not defined), 
#   caches are still initialised (using indexed cacheops), but otherwise 
#   no cacheops are used, and KSEG0 is configured as uncached.

BUILD_DEFS = $(WORKAROUND_BONITO) $(WORKAROUND_NO_CACHE) $(KSEG0_UNCACHED) $(WORKAROUND_CORE_24K) -DSOCITSC_BRINGUP -DMIPSCMP_BRINGUP

# ********************************************************************
# Definitions common to start, little- and big-endian images.
# ********************************************************************

ifeq ($(TOOLCHAIN),sde)
 ifneq (,$(strip $(filter 2,$(GCC_VERSION))))
  AS_OPTS   = -no-traditional-cpp
 endif
TEST_SIZE = test_size
endif

TOOLDIR = $(MAKEDIR)/tools

# Converter tool.
# Converts from srecord file to flash and binary files.
# The srecord file used is actually the concatenation of 3 files : 
# 1) The srecord file holding the reset code.
# 2) The srecord file holding the little endian code.
# 3) The srecord file holding the big endian code.
SRECCONV      = $(PERL) $(TOOLDIR)/srecconv.pl

# Options for srecconv tool
# -ES B is overwritten by "!B" or "!E" inserted in file to be converted.
# -EB B is required by the SEAD and SEAD-2 platforms.
SRECCONV_OPTS = -ES B -EB B -A 29

# Path to include directory.
INCLUDE   = -I$(ROOT)/include -I$(ROOT)/arch/include

# Options to compiler.
#
# Define DEBUG if you whish debug output on debug serial port.
# DEBUG = -D_DEBUG_
#
# Define SIMULATE if building image for simulation.
# SIMULATE = -D_SIMULATE_

W_OPTS    = -Wimplicit -Wformat
REV_OPTS  = '-D_REVMAJ_="$(REVMAJ)"' '-D_REVMIN_="$(REVMIN)"'

ifndef CPUTUNE
 ifeq (4,$(strip $(filter 4,$(GCC_VERSION))))
  CPUTUNE	=-mtune=r4600 -march=r4600 -mabi=32 -mips3
 else
  ifeq (3,$(strip $(filter 3,$(GCC_VERSION))))
    CPUTUNE	=-mtune=r4600 -mips2
   else
    CPUTUNE	=-mcpu=r4600 -mips2
  endif
 endif
endif

CC_OPTS   = $(CPUTUNE) -g -D_32_ -O2 -G0 -fno-builtin $(W_OPTS) $(REV_OPTS) $(INCLUDE) $(DEBUG) $(SIMULATE) $(BUILD_DEFS) -$(ENDIAN) -D$(ENDIAN)

ifeq ($(shell if [ -d $(ROOT)/fpuemul/math ]; then echo exists; fi),exists)
CC_OPTS += -DENABLE_SOFT_FPU
endif

ifeq ($(TOOLCHAIN),linux)
CC_OPTS   += -mno-abicalls -fno-pic
endif

ifeq ($(BSS_OLD),0)
CC_OPTS_A = $(CC_OPTS) $(AS_OPTS) -D_ASSEMBLER_
else
CC_OPTS_A = $(CC_OPTS) $(AS_OPTS) -D_ASSEMBLER_ -D_BSS_OLD_
endif

# This makefile.
MAKEFILE  = $(MAKEDIR)/Makefile

# Options to linker (currently none).
LD_OPTS   =

ifneq (,$(strip $(filter 2,$(GCC_VERSION))))
  BFDPREF	  = elf32-
else
  BFDPREF	  = elf32-trad
endif

# Linker output format.
ifeq ($(ENDIAN),EB)
  OFORMAT   = $(BFDPREF)bigmips
else
  OFORMAT   = $(BFDPREF)littlemips
endif

# Options to objdump
OBJDUMP_OPTS = --disassemble-all -mmips:isa32r2

# Search path for source files.
VPATH  = $(SRCDIR)

# Source files (C and Assembler).
SRC_C  = $(foreach dir, $(SRCDIR), $(wildcard $(dir)/*.c))
SRC_S  = $(foreach dir, $(SRCDIR), $(wildcard $(dir)/*.S))
SRC_H  = $(foreach dir, $(INCLUDE), $(wildcard $(dir)/*.h))
SRC    = $(SRC_C) $(SRC_S)

# Object files.
OBJ_C  = $(notdir $(patsubst %.c, %.o, $(SRC_C)))
OBJ_S  = $(notdir $(patsubst %.S, %.o, $(SRC_S)))
OBJ    = $(OBJ_C) $(OBJ_S) $(FPUEMUL)


# ********************************************************************
# Targets
# ********************************************************************

.PHONY : all install test_install srec_el srec_eb release set_time clean depend dep 

all : test_install set_time fpuemul $(IMAGE_FLASH)

install :
	$(CD) $(ROOT)/fpuemul; $(MAKE) install
	-$(MKDIR) -p EL
	-$(MKDIR) -p EB

test_install :
	@$(PERL) $(TOOLDIR)/test_install.pl

fpuemul :
	$(CD) $(ROOT)/fpuemul; $(MAKE) TOOLCHAIN=$(TOOLCHAIN) CC=$(CC) LD=$(LD) CPUTUNE="$(CPUTUNE)" GCC_VERSION=$(GCC_VERSION) BFDPREF=$(BFDPREF)

test_size :
	@echo Checking size...
	@space=`$(OBJDUMP) -h $(IMAGE_ELF) | \
	awk 'BEGIN { load = 0; size = 0 } \
	     /dat/ { \
		    $$5=substr($$5, length($$5)-7, 8); \
		    load = $$3; size = $$5; \
	     } \
	     END { print "16 i ",load,size,"+ $(MAX_ADDRESS) - p "}' | \
	tr '[a-f]' '[A-F]' | dc` ;\
	if test $$space -gt 0; then \
	    echo "" ;\
	    echo "" ;\
	    echo "$(IMAGE_ELF) $$space bytes too big!!!" ;\
	    echo "" ;\
	    exit 1 ;\
	fi

dis : $(IMAGE_DIS) dis_el dis_eb

dis_el :
	$(CD) $(EL_PATH); $(MAKE) -f ./../$(MAKEFILE) ENDIAN=EL $(DIS_EL)

dis_eb :
	$(CD) $(EB_PATH); $(MAKE) -f ./../$(MAKEFILE) ENDIAN=EB $(DIS_EB)

$(IMAGE_DIS) : $(IMAGE_ELF)
	$(OBJDUMP) $(OBJDUMP_OPTS) $(IMAGE_ELF) > $(IMAGE_DIS)

release :
	$(MAKE) clean        
	$(MAKE) all
	$(MAKE) dis

set_time :
	$(RM) -f $(EL_PATH)/comptime.o $(EB_PATH)/comptime.o

# Build the final flash and binary images :
# 1) Concatenate srecord files for the reset code, big- and little-endian code.
# 2) Apply SRECCONV tool.
$(IMAGE_FLASH) : $(IMAGE_SREC) srec_el srec_eb
	$(ECHO) "!L" > ./tmp_little
	$(ECHO) "!B" > ./tmp_big
ifeq ($(ENDIAN),EB)
	$(CAT) ./tmp_big    $(IMAGE_SREC)\
	       ./tmp_little $(EL_PATH)/$(SREC_EL)\
	       ./tmp_big    $(EB_PATH)/$(SREC_EB)\
	           > $(IMAGE_SREC_CONCAT)
else
	$(CAT) ./tmp_little $(IMAGE_SREC)\
	       ./tmp_little $(EL_PATH)/$(SREC_EL)\
	       ./tmp_big    $(EB_PATH)/$(SREC_EB)\
	           > $(IMAGE_SREC_CONCAT)
endif
	$(RM) ./tmp_little
	$(RM) ./tmp_big
	$(SRECCONV) $(SRECCONV_OPTS) ./$(IMAGENAME)

$(IMAGE_SREC) : $(IMAGE_ELF)
	$(OBJCOPY) -O srec $(IMAGE_ELF) $(IMAGE_SREC)

$(IMAGE_ELF) : $(OBJ) $(LD_SCRIPT)
	$(LD) $(LD_OPTS) -T $(LD_SCRIPT) -o $(IMAGE_ELF) -Map $(IMAGE_MAP) --oformat $(OFORMAT) $(OBJ)

$(OBJ_C) : %.o : %.c 
	$(CC) -c $(CC_OPTS) -o $@ $<

$(OBJ_S) : %.o : %.S
	$(CC) -c $(CC_OPTS_A) -o $@ $<

$(OBJ) : $(MAKEFILE)

srec_el :
	$(CD) $(EL_PATH); \
	$(MAKE) -f ./../$(MAKEFILE) ENDIAN=EL $(SREC_EL) $(TEST_SIZE)

srec_eb :
	$(CD) $(EB_PATH); \
	$(MAKE) -f ./../$(MAKEFILE) ENDIAN=EB $(SREC_EB) $(TEST_SIZE)

CLEAN_FILES = ../TAGS ./*.o ./*.bin ./*.elf ./*.rec ./*.map ./*.dis ./bcfg.fl ./$(RESET).fl ./$(IMAGE_BASENAME)*.fl ./depend.mk

clean :
	-$(RM) -f $(CLEAN_FILES)
	-$(CD) $(EL_PATH); $(RM) -f $(CLEAN_FILES)
	-$(CD) $(EB_PATH); $(RM) -f $(CLEAN_FILES)
	-$(CD) $(ROOT)/fpuemul; $(MAKE) clean

depend: test_install dep
	$(CD) $(EL_PATH); $(MAKE) -f ./../$(MAKEFILE) ENDIAN=EL dep
	$(CD) $(EB_PATH); $(MAKE) -f ./../$(MAKEFILE) ENDIAN=EB dep
	$(CD) $(ROOT)/fpuemul; $(MAKE) TOOLCHAIN=$(TOOLCHAIN) CC=$(CC) depend

TAGS:
	(cd ..; rm -f TAGS; find . -name "*.[chS]" | xargs $(TAGS) --append -t $(ETAGS))

dep:
	$(CC) $(INCLUDE) -M $(SRC) > ./depend.mk

-include ./depend.mk



